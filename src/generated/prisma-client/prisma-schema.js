module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateMyreward {
  count: Int!
}

type AggregateMytask {
  count: Int!
}

type AggregateOption {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateReward {
  count: Int!
}

type AggregateTask {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createMyreward(data: MyrewardCreateInput!): Myreward!
  updateMyreward(data: MyrewardUpdateInput!, where: MyrewardWhereUniqueInput!): Myreward
  upsertMyreward(where: MyrewardWhereUniqueInput!, create: MyrewardCreateInput!, update: MyrewardUpdateInput!): Myreward!
  deleteMyreward(where: MyrewardWhereUniqueInput!): Myreward
  deleteManyMyrewards(where: MyrewardWhereInput): BatchPayload!
  createMytask(data: MytaskCreateInput!): Mytask!
  updateMytask(data: MytaskUpdateInput!, where: MytaskWhereUniqueInput!): Mytask
  updateManyMytasks(data: MytaskUpdateManyMutationInput!, where: MytaskWhereInput): BatchPayload!
  upsertMytask(where: MytaskWhereUniqueInput!, create: MytaskCreateInput!, update: MytaskUpdateInput!): Mytask!
  deleteMytask(where: MytaskWhereUniqueInput!): Mytask
  deleteManyMytasks(where: MytaskWhereInput): BatchPayload!
  createOption(data: OptionCreateInput!): Option!
  updateOption(data: OptionUpdateInput!, where: OptionWhereUniqueInput!): Option
  updateManyOptions(data: OptionUpdateManyMutationInput!, where: OptionWhereInput): BatchPayload!
  upsertOption(where: OptionWhereUniqueInput!, create: OptionCreateInput!, update: OptionUpdateInput!): Option!
  deleteOption(where: OptionWhereUniqueInput!): Option
  deleteManyOptions(where: OptionWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  upsertQuestion(where: QuestionWhereUniqueInput!, create: QuestionCreateInput!, update: QuestionUpdateInput!): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createReward(data: RewardCreateInput!): Reward!
  updateReward(data: RewardUpdateInput!, where: RewardWhereUniqueInput!): Reward
  updateManyRewards(data: RewardUpdateManyMutationInput!, where: RewardWhereInput): BatchPayload!
  upsertReward(where: RewardWhereUniqueInput!, create: RewardCreateInput!, update: RewardUpdateInput!): Reward!
  deleteReward(where: RewardWhereUniqueInput!): Reward
  deleteManyRewards(where: RewardWhereInput): BatchPayload!
  createTask(data: TaskCreateInput!): Task!
  updateTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateManyTasks(data: TaskUpdateManyMutationInput!, where: TaskWhereInput): BatchPayload!
  upsertTask(where: TaskWhereUniqueInput!, create: TaskCreateInput!, update: TaskUpdateInput!): Task!
  deleteTask(where: TaskWhereUniqueInput!): Task
  deleteManyTasks(where: TaskWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Myreward {
  id: ID!
  user: User!
  reward: Reward!
}

type MyrewardConnection {
  pageInfo: PageInfo!
  edges: [MyrewardEdge]!
  aggregate: AggregateMyreward!
}

input MyrewardCreateInput {
  id: ID
  user: UserCreateOneWithoutMyrewardsInput!
  reward: RewardCreateOneWithoutMyrewardsInput!
}

input MyrewardCreateManyWithoutRewardInput {
  create: [MyrewardCreateWithoutRewardInput!]
  connect: [MyrewardWhereUniqueInput!]
}

input MyrewardCreateManyWithoutUserInput {
  create: [MyrewardCreateWithoutUserInput!]
  connect: [MyrewardWhereUniqueInput!]
}

input MyrewardCreateWithoutRewardInput {
  id: ID
  user: UserCreateOneWithoutMyrewardsInput!
}

input MyrewardCreateWithoutUserInput {
  id: ID
  reward: RewardCreateOneWithoutMyrewardsInput!
}

type MyrewardEdge {
  node: Myreward!
  cursor: String!
}

enum MyrewardOrderByInput {
  id_ASC
  id_DESC
}

type MyrewardPreviousValues {
  id: ID!
}

input MyrewardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [MyrewardScalarWhereInput!]
  OR: [MyrewardScalarWhereInput!]
  NOT: [MyrewardScalarWhereInput!]
}

type MyrewardSubscriptionPayload {
  mutation: MutationType!
  node: Myreward
  updatedFields: [String!]
  previousValues: MyrewardPreviousValues
}

input MyrewardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MyrewardWhereInput
  AND: [MyrewardSubscriptionWhereInput!]
  OR: [MyrewardSubscriptionWhereInput!]
  NOT: [MyrewardSubscriptionWhereInput!]
}

input MyrewardUpdateInput {
  user: UserUpdateOneRequiredWithoutMyrewardsInput
  reward: RewardUpdateOneRequiredWithoutMyrewardsInput
}

input MyrewardUpdateManyWithoutRewardInput {
  create: [MyrewardCreateWithoutRewardInput!]
  delete: [MyrewardWhereUniqueInput!]
  connect: [MyrewardWhereUniqueInput!]
  set: [MyrewardWhereUniqueInput!]
  disconnect: [MyrewardWhereUniqueInput!]
  update: [MyrewardUpdateWithWhereUniqueWithoutRewardInput!]
  upsert: [MyrewardUpsertWithWhereUniqueWithoutRewardInput!]
  deleteMany: [MyrewardScalarWhereInput!]
}

input MyrewardUpdateManyWithoutUserInput {
  create: [MyrewardCreateWithoutUserInput!]
  delete: [MyrewardWhereUniqueInput!]
  connect: [MyrewardWhereUniqueInput!]
  set: [MyrewardWhereUniqueInput!]
  disconnect: [MyrewardWhereUniqueInput!]
  update: [MyrewardUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [MyrewardUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [MyrewardScalarWhereInput!]
}

input MyrewardUpdateWithoutRewardDataInput {
  user: UserUpdateOneRequiredWithoutMyrewardsInput
}

input MyrewardUpdateWithoutUserDataInput {
  reward: RewardUpdateOneRequiredWithoutMyrewardsInput
}

input MyrewardUpdateWithWhereUniqueWithoutRewardInput {
  where: MyrewardWhereUniqueInput!
  data: MyrewardUpdateWithoutRewardDataInput!
}

input MyrewardUpdateWithWhereUniqueWithoutUserInput {
  where: MyrewardWhereUniqueInput!
  data: MyrewardUpdateWithoutUserDataInput!
}

input MyrewardUpsertWithWhereUniqueWithoutRewardInput {
  where: MyrewardWhereUniqueInput!
  update: MyrewardUpdateWithoutRewardDataInput!
  create: MyrewardCreateWithoutRewardInput!
}

input MyrewardUpsertWithWhereUniqueWithoutUserInput {
  where: MyrewardWhereUniqueInput!
  update: MyrewardUpdateWithoutUserDataInput!
  create: MyrewardCreateWithoutUserInput!
}

input MyrewardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  reward: RewardWhereInput
  AND: [MyrewardWhereInput!]
  OR: [MyrewardWhereInput!]
  NOT: [MyrewardWhereInput!]
}

input MyrewardWhereUniqueInput {
  id: ID
}

type Mytask {
  id: ID!
  user: User!
  task: Task!
  metadata: String!
}

type MytaskConnection {
  pageInfo: PageInfo!
  edges: [MytaskEdge]!
  aggregate: AggregateMytask!
}

input MytaskCreateInput {
  id: ID
  user: UserCreateOneWithoutMytasksInput!
  task: TaskCreateOneWithoutMytasksInput!
  metadata: String!
}

input MytaskCreateManyWithoutTaskInput {
  create: [MytaskCreateWithoutTaskInput!]
  connect: [MytaskWhereUniqueInput!]
}

input MytaskCreateManyWithoutUserInput {
  create: [MytaskCreateWithoutUserInput!]
  connect: [MytaskWhereUniqueInput!]
}

input MytaskCreateWithoutTaskInput {
  id: ID
  user: UserCreateOneWithoutMytasksInput!
  metadata: String!
}

input MytaskCreateWithoutUserInput {
  id: ID
  task: TaskCreateOneWithoutMytasksInput!
  metadata: String!
}

type MytaskEdge {
  node: Mytask!
  cursor: String!
}

enum MytaskOrderByInput {
  id_ASC
  id_DESC
  metadata_ASC
  metadata_DESC
}

type MytaskPreviousValues {
  id: ID!
  metadata: String!
}

input MytaskScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  metadata: String
  metadata_not: String
  metadata_in: [String!]
  metadata_not_in: [String!]
  metadata_lt: String
  metadata_lte: String
  metadata_gt: String
  metadata_gte: String
  metadata_contains: String
  metadata_not_contains: String
  metadata_starts_with: String
  metadata_not_starts_with: String
  metadata_ends_with: String
  metadata_not_ends_with: String
  AND: [MytaskScalarWhereInput!]
  OR: [MytaskScalarWhereInput!]
  NOT: [MytaskScalarWhereInput!]
}

type MytaskSubscriptionPayload {
  mutation: MutationType!
  node: Mytask
  updatedFields: [String!]
  previousValues: MytaskPreviousValues
}

input MytaskSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MytaskWhereInput
  AND: [MytaskSubscriptionWhereInput!]
  OR: [MytaskSubscriptionWhereInput!]
  NOT: [MytaskSubscriptionWhereInput!]
}

input MytaskUpdateInput {
  user: UserUpdateOneRequiredWithoutMytasksInput
  task: TaskUpdateOneRequiredWithoutMytasksInput
  metadata: String
}

input MytaskUpdateManyDataInput {
  metadata: String
}

input MytaskUpdateManyMutationInput {
  metadata: String
}

input MytaskUpdateManyWithoutTaskInput {
  create: [MytaskCreateWithoutTaskInput!]
  delete: [MytaskWhereUniqueInput!]
  connect: [MytaskWhereUniqueInput!]
  set: [MytaskWhereUniqueInput!]
  disconnect: [MytaskWhereUniqueInput!]
  update: [MytaskUpdateWithWhereUniqueWithoutTaskInput!]
  upsert: [MytaskUpsertWithWhereUniqueWithoutTaskInput!]
  deleteMany: [MytaskScalarWhereInput!]
  updateMany: [MytaskUpdateManyWithWhereNestedInput!]
}

input MytaskUpdateManyWithoutUserInput {
  create: [MytaskCreateWithoutUserInput!]
  delete: [MytaskWhereUniqueInput!]
  connect: [MytaskWhereUniqueInput!]
  set: [MytaskWhereUniqueInput!]
  disconnect: [MytaskWhereUniqueInput!]
  update: [MytaskUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [MytaskUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [MytaskScalarWhereInput!]
  updateMany: [MytaskUpdateManyWithWhereNestedInput!]
}

input MytaskUpdateManyWithWhereNestedInput {
  where: MytaskScalarWhereInput!
  data: MytaskUpdateManyDataInput!
}

input MytaskUpdateWithoutTaskDataInput {
  user: UserUpdateOneRequiredWithoutMytasksInput
  metadata: String
}

input MytaskUpdateWithoutUserDataInput {
  task: TaskUpdateOneRequiredWithoutMytasksInput
  metadata: String
}

input MytaskUpdateWithWhereUniqueWithoutTaskInput {
  where: MytaskWhereUniqueInput!
  data: MytaskUpdateWithoutTaskDataInput!
}

input MytaskUpdateWithWhereUniqueWithoutUserInput {
  where: MytaskWhereUniqueInput!
  data: MytaskUpdateWithoutUserDataInput!
}

input MytaskUpsertWithWhereUniqueWithoutTaskInput {
  where: MytaskWhereUniqueInput!
  update: MytaskUpdateWithoutTaskDataInput!
  create: MytaskCreateWithoutTaskInput!
}

input MytaskUpsertWithWhereUniqueWithoutUserInput {
  where: MytaskWhereUniqueInput!
  update: MytaskUpdateWithoutUserDataInput!
  create: MytaskCreateWithoutUserInput!
}

input MytaskWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  task: TaskWhereInput
  metadata: String
  metadata_not: String
  metadata_in: [String!]
  metadata_not_in: [String!]
  metadata_lt: String
  metadata_lte: String
  metadata_gt: String
  metadata_gte: String
  metadata_contains: String
  metadata_not_contains: String
  metadata_starts_with: String
  metadata_not_starts_with: String
  metadata_ends_with: String
  metadata_not_ends_with: String
  AND: [MytaskWhereInput!]
  OR: [MytaskWhereInput!]
  NOT: [MytaskWhereInput!]
}

input MytaskWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Option {
  id: ID!
  optionText: String!
  question: Question
}

type OptionConnection {
  pageInfo: PageInfo!
  edges: [OptionEdge]!
  aggregate: AggregateOption!
}

input OptionCreateInput {
  id: ID
  optionText: String!
  question: QuestionCreateOneWithoutOptionsInput
}

input OptionCreateManyWithoutQuestionInput {
  create: [OptionCreateWithoutQuestionInput!]
  connect: [OptionWhereUniqueInput!]
}

input OptionCreateWithoutQuestionInput {
  id: ID
  optionText: String!
}

type OptionEdge {
  node: Option!
  cursor: String!
}

enum OptionOrderByInput {
  id_ASC
  id_DESC
  optionText_ASC
  optionText_DESC
}

type OptionPreviousValues {
  id: ID!
  optionText: String!
}

input OptionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  optionText: String
  optionText_not: String
  optionText_in: [String!]
  optionText_not_in: [String!]
  optionText_lt: String
  optionText_lte: String
  optionText_gt: String
  optionText_gte: String
  optionText_contains: String
  optionText_not_contains: String
  optionText_starts_with: String
  optionText_not_starts_with: String
  optionText_ends_with: String
  optionText_not_ends_with: String
  AND: [OptionScalarWhereInput!]
  OR: [OptionScalarWhereInput!]
  NOT: [OptionScalarWhereInput!]
}

type OptionSubscriptionPayload {
  mutation: MutationType!
  node: Option
  updatedFields: [String!]
  previousValues: OptionPreviousValues
}

input OptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OptionWhereInput
  AND: [OptionSubscriptionWhereInput!]
  OR: [OptionSubscriptionWhereInput!]
  NOT: [OptionSubscriptionWhereInput!]
}

input OptionUpdateInput {
  optionText: String
  question: QuestionUpdateOneWithoutOptionsInput
}

input OptionUpdateManyDataInput {
  optionText: String
}

input OptionUpdateManyMutationInput {
  optionText: String
}

input OptionUpdateManyWithoutQuestionInput {
  create: [OptionCreateWithoutQuestionInput!]
  delete: [OptionWhereUniqueInput!]
  connect: [OptionWhereUniqueInput!]
  set: [OptionWhereUniqueInput!]
  disconnect: [OptionWhereUniqueInput!]
  update: [OptionUpdateWithWhereUniqueWithoutQuestionInput!]
  upsert: [OptionUpsertWithWhereUniqueWithoutQuestionInput!]
  deleteMany: [OptionScalarWhereInput!]
  updateMany: [OptionUpdateManyWithWhereNestedInput!]
}

input OptionUpdateManyWithWhereNestedInput {
  where: OptionScalarWhereInput!
  data: OptionUpdateManyDataInput!
}

input OptionUpdateWithoutQuestionDataInput {
  optionText: String
}

input OptionUpdateWithWhereUniqueWithoutQuestionInput {
  where: OptionWhereUniqueInput!
  data: OptionUpdateWithoutQuestionDataInput!
}

input OptionUpsertWithWhereUniqueWithoutQuestionInput {
  where: OptionWhereUniqueInput!
  update: OptionUpdateWithoutQuestionDataInput!
  create: OptionCreateWithoutQuestionInput!
}

input OptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  optionText: String
  optionText_not: String
  optionText_in: [String!]
  optionText_not_in: [String!]
  optionText_lt: String
  optionText_lte: String
  optionText_gt: String
  optionText_gte: String
  optionText_contains: String
  optionText_not_contains: String
  optionText_starts_with: String
  optionText_not_starts_with: String
  optionText_ends_with: String
  optionText_not_ends_with: String
  question: QuestionWhereInput
  AND: [OptionWhereInput!]
  OR: [OptionWhereInput!]
  NOT: [OptionWhereInput!]
}

input OptionWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  myreward(where: MyrewardWhereUniqueInput!): Myreward
  myrewards(where: MyrewardWhereInput, orderBy: MyrewardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Myreward]!
  myrewardsConnection(where: MyrewardWhereInput, orderBy: MyrewardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MyrewardConnection!
  mytask(where: MytaskWhereUniqueInput!): Mytask
  mytasks(where: MytaskWhereInput, orderBy: MytaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mytask]!
  mytasksConnection(where: MytaskWhereInput, orderBy: MytaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MytaskConnection!
  option(where: OptionWhereUniqueInput!): Option
  options(where: OptionWhereInput, orderBy: OptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Option]!
  optionsConnection(where: OptionWhereInput, orderBy: OptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OptionConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question]!
  questionsConnection(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConnection!
  reward(where: RewardWhereUniqueInput!): Reward
  rewards(where: RewardWhereInput, orderBy: RewardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reward]!
  rewardsConnection(where: RewardWhereInput, orderBy: RewardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RewardConnection!
  task(where: TaskWhereUniqueInput!): Task
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task]!
  tasksConnection(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TaskConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  questionText: String!
  options(where: OptionWhereInput, orderBy: OptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Option!]
  task: Task
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateInput {
  id: ID
  questionText: String!
  options: OptionCreateManyWithoutQuestionInput
  task: TaskCreateOneWithoutQuestionsInput
}

input QuestionCreateManyWithoutTaskInput {
  create: [QuestionCreateWithoutTaskInput!]
  connect: [QuestionWhereUniqueInput!]
}

input QuestionCreateOneWithoutOptionsInput {
  create: QuestionCreateWithoutOptionsInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateWithoutOptionsInput {
  id: ID
  questionText: String!
  task: TaskCreateOneWithoutQuestionsInput
}

input QuestionCreateWithoutTaskInput {
  id: ID
  questionText: String!
  options: OptionCreateManyWithoutQuestionInput
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  questionText_ASC
  questionText_DESC
}

type QuestionPreviousValues {
  id: ID!
  questionText: String!
}

input QuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  questionText: String
  questionText_not: String
  questionText_in: [String!]
  questionText_not_in: [String!]
  questionText_lt: String
  questionText_lte: String
  questionText_gt: String
  questionText_gte: String
  questionText_contains: String
  questionText_not_contains: String
  questionText_starts_with: String
  questionText_not_starts_with: String
  questionText_ends_with: String
  questionText_not_ends_with: String
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

input QuestionUpdateInput {
  questionText: String
  options: OptionUpdateManyWithoutQuestionInput
  task: TaskUpdateOneWithoutQuestionsInput
}

input QuestionUpdateManyDataInput {
  questionText: String
}

input QuestionUpdateManyMutationInput {
  questionText: String
}

input QuestionUpdateManyWithoutTaskInput {
  create: [QuestionCreateWithoutTaskInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutTaskInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutTaskInput!]
  deleteMany: [QuestionScalarWhereInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
}

input QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyDataInput!
}

input QuestionUpdateOneWithoutOptionsInput {
  create: QuestionCreateWithoutOptionsInput
  update: QuestionUpdateWithoutOptionsDataInput
  upsert: QuestionUpsertWithoutOptionsInput
  delete: Boolean
  disconnect: Boolean
  connect: QuestionWhereUniqueInput
}

input QuestionUpdateWithoutOptionsDataInput {
  questionText: String
  task: TaskUpdateOneWithoutQuestionsInput
}

input QuestionUpdateWithoutTaskDataInput {
  questionText: String
  options: OptionUpdateManyWithoutQuestionInput
}

input QuestionUpdateWithWhereUniqueWithoutTaskInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateWithoutTaskDataInput!
}

input QuestionUpsertWithoutOptionsInput {
  update: QuestionUpdateWithoutOptionsDataInput!
  create: QuestionCreateWithoutOptionsInput!
}

input QuestionUpsertWithWhereUniqueWithoutTaskInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateWithoutTaskDataInput!
  create: QuestionCreateWithoutTaskInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  questionText: String
  questionText_not: String
  questionText_in: [String!]
  questionText_not_in: [String!]
  questionText_lt: String
  questionText_lte: String
  questionText_gt: String
  questionText_gte: String
  questionText_contains: String
  questionText_not_contains: String
  questionText_starts_with: String
  questionText_not_starts_with: String
  questionText_ends_with: String
  questionText_not_ends_with: String
  options_every: OptionWhereInput
  options_some: OptionWhereInput
  options_none: OptionWhereInput
  task: TaskWhereInput
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

type Reward {
  id: ID!
  decription: String
  url: String!
  myrewards(where: MyrewardWhereInput, orderBy: MyrewardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Myreward!]
  equivalentScore: Int!
}

type RewardConnection {
  pageInfo: PageInfo!
  edges: [RewardEdge]!
  aggregate: AggregateReward!
}

input RewardCreateInput {
  id: ID
  decription: String
  url: String!
  myrewards: MyrewardCreateManyWithoutRewardInput
  equivalentScore: Int!
}

input RewardCreateOneWithoutMyrewardsInput {
  create: RewardCreateWithoutMyrewardsInput
  connect: RewardWhereUniqueInput
}

input RewardCreateWithoutMyrewardsInput {
  id: ID
  decription: String
  url: String!
  equivalentScore: Int!
}

type RewardEdge {
  node: Reward!
  cursor: String!
}

enum RewardOrderByInput {
  id_ASC
  id_DESC
  decription_ASC
  decription_DESC
  url_ASC
  url_DESC
  equivalentScore_ASC
  equivalentScore_DESC
}

type RewardPreviousValues {
  id: ID!
  decription: String
  url: String!
  equivalentScore: Int!
}

type RewardSubscriptionPayload {
  mutation: MutationType!
  node: Reward
  updatedFields: [String!]
  previousValues: RewardPreviousValues
}

input RewardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RewardWhereInput
  AND: [RewardSubscriptionWhereInput!]
  OR: [RewardSubscriptionWhereInput!]
  NOT: [RewardSubscriptionWhereInput!]
}

input RewardUpdateInput {
  decription: String
  url: String
  myrewards: MyrewardUpdateManyWithoutRewardInput
  equivalentScore: Int
}

input RewardUpdateManyMutationInput {
  decription: String
  url: String
  equivalentScore: Int
}

input RewardUpdateOneRequiredWithoutMyrewardsInput {
  create: RewardCreateWithoutMyrewardsInput
  update: RewardUpdateWithoutMyrewardsDataInput
  upsert: RewardUpsertWithoutMyrewardsInput
  connect: RewardWhereUniqueInput
}

input RewardUpdateWithoutMyrewardsDataInput {
  decription: String
  url: String
  equivalentScore: Int
}

input RewardUpsertWithoutMyrewardsInput {
  update: RewardUpdateWithoutMyrewardsDataInput!
  create: RewardCreateWithoutMyrewardsInput!
}

input RewardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  decription: String
  decription_not: String
  decription_in: [String!]
  decription_not_in: [String!]
  decription_lt: String
  decription_lte: String
  decription_gt: String
  decription_gte: String
  decription_contains: String
  decription_not_contains: String
  decription_starts_with: String
  decription_not_starts_with: String
  decription_ends_with: String
  decription_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  myrewards_every: MyrewardWhereInput
  myrewards_some: MyrewardWhereInput
  myrewards_none: MyrewardWhereInput
  equivalentScore: Int
  equivalentScore_not: Int
  equivalentScore_in: [Int!]
  equivalentScore_not_in: [Int!]
  equivalentScore_lt: Int
  equivalentScore_lte: Int
  equivalentScore_gt: Int
  equivalentScore_gte: Int
  AND: [RewardWhereInput!]
  OR: [RewardWhereInput!]
  NOT: [RewardWhereInput!]
}

input RewardWhereUniqueInput {
  id: ID
}

type Subscription {
  myreward(where: MyrewardSubscriptionWhereInput): MyrewardSubscriptionPayload
  mytask(where: MytaskSubscriptionWhereInput): MytaskSubscriptionPayload
  option(where: OptionSubscriptionWhereInput): OptionSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  reward(where: RewardSubscriptionWhereInput): RewardSubscriptionPayload
  task(where: TaskSubscriptionWhereInput): TaskSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Task {
  id: ID!
  name: String!
  description: String
  type: String!
  taskScore: Int!
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question!]
  mytasks(where: MytaskWhereInput, orderBy: MytaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mytask!]
}

type TaskConnection {
  pageInfo: PageInfo!
  edges: [TaskEdge]!
  aggregate: AggregateTask!
}

input TaskCreateInput {
  id: ID
  name: String!
  description: String
  type: String!
  taskScore: Int!
  questions: QuestionCreateManyWithoutTaskInput
  mytasks: MytaskCreateManyWithoutTaskInput
}

input TaskCreateOneWithoutMytasksInput {
  create: TaskCreateWithoutMytasksInput
  connect: TaskWhereUniqueInput
}

input TaskCreateOneWithoutQuestionsInput {
  create: TaskCreateWithoutQuestionsInput
  connect: TaskWhereUniqueInput
}

input TaskCreateWithoutMytasksInput {
  id: ID
  name: String!
  description: String
  type: String!
  taskScore: Int!
  questions: QuestionCreateManyWithoutTaskInput
}

input TaskCreateWithoutQuestionsInput {
  id: ID
  name: String!
  description: String
  type: String!
  taskScore: Int!
  mytasks: MytaskCreateManyWithoutTaskInput
}

type TaskEdge {
  node: Task!
  cursor: String!
}

enum TaskOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  taskScore_ASC
  taskScore_DESC
}

type TaskPreviousValues {
  id: ID!
  name: String!
  description: String
  type: String!
  taskScore: Int!
}

type TaskSubscriptionPayload {
  mutation: MutationType!
  node: Task
  updatedFields: [String!]
  previousValues: TaskPreviousValues
}

input TaskSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TaskWhereInput
  AND: [TaskSubscriptionWhereInput!]
  OR: [TaskSubscriptionWhereInput!]
  NOT: [TaskSubscriptionWhereInput!]
}

input TaskUpdateInput {
  name: String
  description: String
  type: String
  taskScore: Int
  questions: QuestionUpdateManyWithoutTaskInput
  mytasks: MytaskUpdateManyWithoutTaskInput
}

input TaskUpdateManyMutationInput {
  name: String
  description: String
  type: String
  taskScore: Int
}

input TaskUpdateOneRequiredWithoutMytasksInput {
  create: TaskCreateWithoutMytasksInput
  update: TaskUpdateWithoutMytasksDataInput
  upsert: TaskUpsertWithoutMytasksInput
  connect: TaskWhereUniqueInput
}

input TaskUpdateOneWithoutQuestionsInput {
  create: TaskCreateWithoutQuestionsInput
  update: TaskUpdateWithoutQuestionsDataInput
  upsert: TaskUpsertWithoutQuestionsInput
  delete: Boolean
  disconnect: Boolean
  connect: TaskWhereUniqueInput
}

input TaskUpdateWithoutMytasksDataInput {
  name: String
  description: String
  type: String
  taskScore: Int
  questions: QuestionUpdateManyWithoutTaskInput
}

input TaskUpdateWithoutQuestionsDataInput {
  name: String
  description: String
  type: String
  taskScore: Int
  mytasks: MytaskUpdateManyWithoutTaskInput
}

input TaskUpsertWithoutMytasksInput {
  update: TaskUpdateWithoutMytasksDataInput!
  create: TaskCreateWithoutMytasksInput!
}

input TaskUpsertWithoutQuestionsInput {
  update: TaskUpdateWithoutQuestionsDataInput!
  create: TaskCreateWithoutQuestionsInput!
}

input TaskWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  taskScore: Int
  taskScore_not: Int
  taskScore_in: [Int!]
  taskScore_not_in: [Int!]
  taskScore_lt: Int
  taskScore_lte: Int
  taskScore_gt: Int
  taskScore_gte: Int
  questions_every: QuestionWhereInput
  questions_some: QuestionWhereInput
  questions_none: QuestionWhereInput
  mytasks_every: MytaskWhereInput
  mytasks_some: MytaskWhereInput
  mytasks_none: MytaskWhereInput
  AND: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  NOT: [TaskWhereInput!]
}

input TaskWhereUniqueInput {
  id: ID
  name: String
}

type User {
  id: ID!
  username: String!
  email: String!
  mytasks(where: MytaskWhereInput, orderBy: MytaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mytask!]
  myrewards(where: MyrewardWhereInput, orderBy: MyrewardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Myreward!]
  score: Int
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String!
  mytasks: MytaskCreateManyWithoutUserInput
  myrewards: MyrewardCreateManyWithoutUserInput
  score: Int
}

input UserCreateOneWithoutMyrewardsInput {
  create: UserCreateWithoutMyrewardsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMytasksInput {
  create: UserCreateWithoutMytasksInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutMyrewardsInput {
  id: ID
  username: String!
  email: String!
  mytasks: MytaskCreateManyWithoutUserInput
  score: Int
}

input UserCreateWithoutMytasksInput {
  id: ID
  username: String!
  email: String!
  myrewards: MyrewardCreateManyWithoutUserInput
  score: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  score_ASC
  score_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  email: String!
  score: Int
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  username: String
  email: String
  mytasks: MytaskUpdateManyWithoutUserInput
  myrewards: MyrewardUpdateManyWithoutUserInput
  score: Int
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  score: Int
}

input UserUpdateOneRequiredWithoutMyrewardsInput {
  create: UserCreateWithoutMyrewardsInput
  update: UserUpdateWithoutMyrewardsDataInput
  upsert: UserUpsertWithoutMyrewardsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutMytasksInput {
  create: UserCreateWithoutMytasksInput
  update: UserUpdateWithoutMytasksDataInput
  upsert: UserUpsertWithoutMytasksInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutMyrewardsDataInput {
  username: String
  email: String
  mytasks: MytaskUpdateManyWithoutUserInput
  score: Int
}

input UserUpdateWithoutMytasksDataInput {
  username: String
  email: String
  myrewards: MyrewardUpdateManyWithoutUserInput
  score: Int
}

input UserUpsertWithoutMyrewardsInput {
  update: UserUpdateWithoutMyrewardsDataInput!
  create: UserCreateWithoutMyrewardsInput!
}

input UserUpsertWithoutMytasksInput {
  update: UserUpdateWithoutMytasksDataInput!
  create: UserCreateWithoutMytasksInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mytasks_every: MytaskWhereInput
  mytasks_some: MytaskWhereInput
  mytasks_none: MytaskWhereInput
  myrewards_every: MyrewardWhereInput
  myrewards_some: MyrewardWhereInput
  myrewards_none: MyrewardWhereInput
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
}
`
      }
    