// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  myreward: (where?: MyrewardWhereInput) => Promise<boolean>;
  mytask: (where?: MytaskWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  reward: (where?: RewardWhereInput) => Promise<boolean>;
  task: (where?: TaskWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  myreward: (where: MyrewardWhereUniqueInput) => MyrewardNullablePromise;
  myrewards: (args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Myreward>;
  myrewardsConnection: (args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MyrewardConnectionPromise;
  mytask: (where: MytaskWhereUniqueInput) => MytaskNullablePromise;
  mytasks: (args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Mytask>;
  mytasksConnection: (args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MytaskConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionNullablePromise;
  options: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Option>;
  optionsConnection: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionNullablePromise;
  questions: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Question>;
  questionsConnection: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConnectionPromise;
  reward: (where: RewardWhereUniqueInput) => RewardNullablePromise;
  rewards: (args?: {
    where?: RewardWhereInput;
    orderBy?: RewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reward>;
  rewardsConnection: (args?: {
    where?: RewardWhereInput;
    orderBy?: RewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RewardConnectionPromise;
  task: (where: TaskWhereUniqueInput) => TaskNullablePromise;
  tasks: (args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Task>;
  tasksConnection: (args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TaskConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createMyreward: (data: MyrewardCreateInput) => MyrewardPromise;
  updateMyreward: (args: {
    data: MyrewardUpdateInput;
    where: MyrewardWhereUniqueInput;
  }) => MyrewardPromise;
  upsertMyreward: (args: {
    where: MyrewardWhereUniqueInput;
    create: MyrewardCreateInput;
    update: MyrewardUpdateInput;
  }) => MyrewardPromise;
  deleteMyreward: (where: MyrewardWhereUniqueInput) => MyrewardPromise;
  deleteManyMyrewards: (where?: MyrewardWhereInput) => BatchPayloadPromise;
  createMytask: (data: MytaskCreateInput) => MytaskPromise;
  updateMytask: (args: {
    data: MytaskUpdateInput;
    where: MytaskWhereUniqueInput;
  }) => MytaskPromise;
  updateManyMytasks: (args: {
    data: MytaskUpdateManyMutationInput;
    where?: MytaskWhereInput;
  }) => BatchPayloadPromise;
  upsertMytask: (args: {
    where: MytaskWhereUniqueInput;
    create: MytaskCreateInput;
    update: MytaskUpdateInput;
  }) => MytaskPromise;
  deleteMytask: (where: MytaskWhereUniqueInput) => MytaskPromise;
  deleteManyMytasks: (where?: MytaskWhereInput) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (args: {
    data: OptionUpdateInput;
    where: OptionWhereUniqueInput;
  }) => OptionPromise;
  updateManyOptions: (args: {
    data: OptionUpdateManyMutationInput;
    where?: OptionWhereInput;
  }) => BatchPayloadPromise;
  upsertOption: (args: {
    where: OptionWhereUniqueInput;
    create: OptionCreateInput;
    update: OptionUpdateInput;
  }) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (args: {
    data: QuestionUpdateInput;
    where: QuestionWhereUniqueInput;
  }) => QuestionPromise;
  updateManyQuestions: (args: {
    data: QuestionUpdateManyMutationInput;
    where?: QuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestion: (args: {
    where: QuestionWhereUniqueInput;
    create: QuestionCreateInput;
    update: QuestionUpdateInput;
  }) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createReward: (data: RewardCreateInput) => RewardPromise;
  updateReward: (args: {
    data: RewardUpdateInput;
    where: RewardWhereUniqueInput;
  }) => RewardPromise;
  updateManyRewards: (args: {
    data: RewardUpdateManyMutationInput;
    where?: RewardWhereInput;
  }) => BatchPayloadPromise;
  upsertReward: (args: {
    where: RewardWhereUniqueInput;
    create: RewardCreateInput;
    update: RewardUpdateInput;
  }) => RewardPromise;
  deleteReward: (where: RewardWhereUniqueInput) => RewardPromise;
  deleteManyRewards: (where?: RewardWhereInput) => BatchPayloadPromise;
  createTask: (data: TaskCreateInput) => TaskPromise;
  updateTask: (args: {
    data: TaskUpdateInput;
    where: TaskWhereUniqueInput;
  }) => TaskPromise;
  updateManyTasks: (args: {
    data: TaskUpdateManyMutationInput;
    where?: TaskWhereInput;
  }) => BatchPayloadPromise;
  upsertTask: (args: {
    where: TaskWhereUniqueInput;
    create: TaskCreateInput;
    update: TaskUpdateInput;
  }) => TaskPromise;
  deleteTask: (where: TaskWhereUniqueInput) => TaskPromise;
  deleteManyTasks: (where?: TaskWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  myreward: (
    where?: MyrewardSubscriptionWhereInput
  ) => MyrewardSubscriptionPayloadSubscription;
  mytask: (
    where?: MytaskSubscriptionWhereInput
  ) => MytaskSubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  reward: (
    where?: RewardSubscriptionWhereInput
  ) => RewardSubscriptionPayloadSubscription;
  task: (
    where?: TaskSubscriptionWhereInput
  ) => TaskSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MytaskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "metadata_ASC"
  | "metadata_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "questionText_ASC"
  | "questionText_DESC";

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "optionText_ASC"
  | "optionText_DESC";

export type MyrewardOrderByInput = "id_ASC" | "id_DESC";

export type RewardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "decription_ASC"
  | "decription_DESC"
  | "url_ASC"
  | "url_DESC"
  | "equivalentScore_ASC"
  | "equivalentScore_DESC";

export type TaskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC"
  | "taskScore_ASC"
  | "taskScore_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "score_ASC"
  | "score_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface QuestionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  questionText?: Maybe<String>;
  questionText_not?: Maybe<String>;
  questionText_in?: Maybe<String[] | String>;
  questionText_not_in?: Maybe<String[] | String>;
  questionText_lt?: Maybe<String>;
  questionText_lte?: Maybe<String>;
  questionText_gt?: Maybe<String>;
  questionText_gte?: Maybe<String>;
  questionText_contains?: Maybe<String>;
  questionText_not_contains?: Maybe<String>;
  questionText_starts_with?: Maybe<String>;
  questionText_not_starts_with?: Maybe<String>;
  questionText_ends_with?: Maybe<String>;
  questionText_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  OR?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  NOT?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
}

export type MyrewardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MytaskScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  metadata?: Maybe<String>;
  metadata_not?: Maybe<String>;
  metadata_in?: Maybe<String[] | String>;
  metadata_not_in?: Maybe<String[] | String>;
  metadata_lt?: Maybe<String>;
  metadata_lte?: Maybe<String>;
  metadata_gt?: Maybe<String>;
  metadata_gte?: Maybe<String>;
  metadata_contains?: Maybe<String>;
  metadata_not_contains?: Maybe<String>;
  metadata_starts_with?: Maybe<String>;
  metadata_not_starts_with?: Maybe<String>;
  metadata_ends_with?: Maybe<String>;
  metadata_not_ends_with?: Maybe<String>;
  AND?: Maybe<MytaskScalarWhereInput[] | MytaskScalarWhereInput>;
  OR?: Maybe<MytaskScalarWhereInput[] | MytaskScalarWhereInput>;
  NOT?: Maybe<MytaskScalarWhereInput[] | MytaskScalarWhereInput>;
}

export interface TaskWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  taskScore?: Maybe<Int>;
  taskScore_not?: Maybe<Int>;
  taskScore_in?: Maybe<Int[] | Int>;
  taskScore_not_in?: Maybe<Int[] | Int>;
  taskScore_lt?: Maybe<Int>;
  taskScore_lte?: Maybe<Int>;
  taskScore_gt?: Maybe<Int>;
  taskScore_gte?: Maybe<Int>;
  questions_every?: Maybe<QuestionWhereInput>;
  questions_some?: Maybe<QuestionWhereInput>;
  questions_none?: Maybe<QuestionWhereInput>;
  mytasks_every?: Maybe<MytaskWhereInput>;
  mytasks_some?: Maybe<MytaskWhereInput>;
  mytasks_none?: Maybe<MytaskWhereInput>;
  AND?: Maybe<TaskWhereInput[] | TaskWhereInput>;
  OR?: Maybe<TaskWhereInput[] | TaskWhereInput>;
  NOT?: Maybe<TaskWhereInput[] | TaskWhereInput>;
}

export interface MytaskUpdateManyWithWhereNestedInput {
  where: MytaskScalarWhereInput;
  data: MytaskUpdateManyDataInput;
}

export interface OptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  optionText?: Maybe<String>;
  optionText_not?: Maybe<String>;
  optionText_in?: Maybe<String[] | String>;
  optionText_not_in?: Maybe<String[] | String>;
  optionText_lt?: Maybe<String>;
  optionText_lte?: Maybe<String>;
  optionText_gt?: Maybe<String>;
  optionText_gte?: Maybe<String>;
  optionText_contains?: Maybe<String>;
  optionText_not_contains?: Maybe<String>;
  optionText_starts_with?: Maybe<String>;
  optionText_not_starts_with?: Maybe<String>;
  optionText_ends_with?: Maybe<String>;
  optionText_not_ends_with?: Maybe<String>;
  question?: Maybe<QuestionWhereInput>;
  AND?: Maybe<OptionWhereInput[] | OptionWhereInput>;
  OR?: Maybe<OptionWhereInput[] | OptionWhereInput>;
  NOT?: Maybe<OptionWhereInput[] | OptionWhereInput>;
}

export interface MytaskUpdateManyWithoutUserInput {
  create?: Maybe<MytaskCreateWithoutUserInput[] | MytaskCreateWithoutUserInput>;
  delete?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  connect?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  set?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  disconnect?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  update?: Maybe<
    | MytaskUpdateWithWhereUniqueWithoutUserInput[]
    | MytaskUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | MytaskUpsertWithWhereUniqueWithoutUserInput[]
    | MytaskUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<MytaskScalarWhereInput[] | MytaskScalarWhereInput>;
  updateMany?: Maybe<
    | MytaskUpdateManyWithWhereNestedInput[]
    | MytaskUpdateManyWithWhereNestedInput
  >;
}

export interface TaskUpdateOneWithoutQuestionsInput {
  create?: Maybe<TaskCreateWithoutQuestionsInput>;
  update?: Maybe<TaskUpdateWithoutQuestionsDataInput>;
  upsert?: Maybe<TaskUpsertWithoutQuestionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface MytaskUpdateWithWhereUniqueWithoutUserInput {
  where: MytaskWhereUniqueInput;
  data: MytaskUpdateWithoutUserDataInput;
}

export interface MytaskUpdateManyDataInput {
  metadata?: Maybe<String>;
}

export interface MytaskUpdateWithoutUserDataInput {
  task?: Maybe<TaskUpdateOneRequiredWithoutMytasksInput>;
  metadata?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface TaskUpdateOneRequiredWithoutMytasksInput {
  create?: Maybe<TaskCreateWithoutMytasksInput>;
  update?: Maybe<TaskUpdateWithoutMytasksDataInput>;
  upsert?: Maybe<TaskUpsertWithoutMytasksInput>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface TaskSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TaskWhereInput>;
  AND?: Maybe<TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput>;
  OR?: Maybe<TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput>;
  NOT?: Maybe<TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput>;
}

export interface TaskUpdateWithoutMytasksDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<String>;
  taskScore?: Maybe<Int>;
  questions?: Maybe<QuestionUpdateManyWithoutTaskInput>;
}

export interface RewardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RewardWhereInput>;
  AND?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
  OR?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
  NOT?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
}

export interface QuestionUpdateManyWithoutTaskInput {
  create?: Maybe<
    QuestionCreateWithoutTaskInput[] | QuestionCreateWithoutTaskInput
  >;
  delete?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  set?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  disconnect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  update?: Maybe<
    | QuestionUpdateWithWhereUniqueWithoutTaskInput[]
    | QuestionUpdateWithWhereUniqueWithoutTaskInput
  >;
  upsert?: Maybe<
    | QuestionUpsertWithWhereUniqueWithoutTaskInput[]
    | QuestionUpsertWithWhereUniqueWithoutTaskInput
  >;
  deleteMany?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  updateMany?: Maybe<
    | QuestionUpdateManyWithWhereNestedInput[]
    | QuestionUpdateManyWithWhereNestedInput
  >;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OptionWhereInput>;
  AND?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
  OR?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
  NOT?: Maybe<OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput>;
}

export interface QuestionUpdateWithWhereUniqueWithoutTaskInput {
  where: QuestionWhereUniqueInput;
  data: QuestionUpdateWithoutTaskDataInput;
}

export interface MyrewardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MyrewardWhereInput>;
  AND?: Maybe<
    MyrewardSubscriptionWhereInput[] | MyrewardSubscriptionWhereInput
  >;
  OR?: Maybe<MyrewardSubscriptionWhereInput[] | MyrewardSubscriptionWhereInput>;
  NOT?: Maybe<
    MyrewardSubscriptionWhereInput[] | MyrewardSubscriptionWhereInput
  >;
}

export interface QuestionUpdateWithoutTaskDataInput {
  questionText?: Maybe<String>;
  options?: Maybe<OptionUpdateManyWithoutQuestionInput>;
}

export type MytaskWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OptionUpdateManyWithoutQuestionInput {
  create?: Maybe<
    OptionCreateWithoutQuestionInput[] | OptionCreateWithoutQuestionInput
  >;
  delete?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  connect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  set?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  disconnect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
  update?: Maybe<
    | OptionUpdateWithWhereUniqueWithoutQuestionInput[]
    | OptionUpdateWithWhereUniqueWithoutQuestionInput
  >;
  upsert?: Maybe<
    | OptionUpsertWithWhereUniqueWithoutQuestionInput[]
    | OptionUpsertWithWhereUniqueWithoutQuestionInput
  >;
  deleteMany?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  updateMany?: Maybe<
    | OptionUpdateManyWithWhereNestedInput[]
    | OptionUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  email: String;
  mytasks?: Maybe<MytaskCreateManyWithoutUserInput>;
  myrewards?: Maybe<MyrewardCreateManyWithoutUserInput>;
  score?: Maybe<Int>;
}

export interface OptionUpdateWithWhereUniqueWithoutQuestionInput {
  where: OptionWhereUniqueInput;
  data: OptionUpdateWithoutQuestionDataInput;
}

export type OptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OptionUpdateWithoutQuestionDataInput {
  optionText?: Maybe<String>;
}

export interface TaskCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type: String;
  taskScore: Int;
  questions?: Maybe<QuestionCreateManyWithoutTaskInput>;
  mytasks?: Maybe<MytaskCreateManyWithoutTaskInput>;
}

export interface OptionUpsertWithWhereUniqueWithoutQuestionInput {
  where: OptionWhereUniqueInput;
  update: OptionUpdateWithoutQuestionDataInput;
  create: OptionCreateWithoutQuestionInput;
}

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  optionText?: Maybe<String>;
  optionText_not?: Maybe<String>;
  optionText_in?: Maybe<String[] | String>;
  optionText_not_in?: Maybe<String[] | String>;
  optionText_lt?: Maybe<String>;
  optionText_lte?: Maybe<String>;
  optionText_gt?: Maybe<String>;
  optionText_gte?: Maybe<String>;
  optionText_contains?: Maybe<String>;
  optionText_not_contains?: Maybe<String>;
  optionText_starts_with?: Maybe<String>;
  optionText_not_starts_with?: Maybe<String>;
  optionText_ends_with?: Maybe<String>;
  optionText_not_ends_with?: Maybe<String>;
  AND?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  OR?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
  NOT?: Maybe<OptionScalarWhereInput[] | OptionScalarWhereInput>;
}

export interface MyrewardUpdateWithoutRewardDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMyrewardsInput>;
}

export interface OptionUpdateManyWithWhereNestedInput {
  where: OptionScalarWhereInput;
  data: OptionUpdateManyDataInput;
}

export type RewardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OptionUpdateManyDataInput {
  optionText?: Maybe<String>;
}

export interface MyrewardUpdateManyWithoutRewardInput {
  create?: Maybe<
    MyrewardCreateWithoutRewardInput[] | MyrewardCreateWithoutRewardInput
  >;
  delete?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  connect?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  set?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  disconnect?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  update?: Maybe<
    | MyrewardUpdateWithWhereUniqueWithoutRewardInput[]
    | MyrewardUpdateWithWhereUniqueWithoutRewardInput
  >;
  upsert?: Maybe<
    | MyrewardUpsertWithWhereUniqueWithoutRewardInput[]
    | MyrewardUpsertWithWhereUniqueWithoutRewardInput
  >;
  deleteMany?: Maybe<MyrewardScalarWhereInput[] | MyrewardScalarWhereInput>;
}

export interface QuestionUpsertWithWhereUniqueWithoutTaskInput {
  where: QuestionWhereUniqueInput;
  update: QuestionUpdateWithoutTaskDataInput;
  create: QuestionCreateWithoutTaskInput;
}

export interface MyrewardCreateWithoutRewardInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMyrewardsInput;
}

export interface MytaskUpsertWithWhereUniqueWithoutTaskInput {
  where: MytaskWhereUniqueInput;
  update: MytaskUpdateWithoutTaskDataInput;
  create: MytaskCreateWithoutTaskInput;
}

export interface MyrewardCreateManyWithoutRewardInput {
  create?: Maybe<
    MyrewardCreateWithoutRewardInput[] | MyrewardCreateWithoutRewardInput
  >;
  connect?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
}

export interface QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput;
  data: QuestionUpdateManyDataInput;
}

export interface QuestionUpdateManyMutationInput {
  questionText?: Maybe<String>;
}

export interface QuestionUpdateManyDataInput {
  questionText?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface TaskUpsertWithoutMytasksInput {
  update: TaskUpdateWithoutMytasksDataInput;
  create: TaskCreateWithoutMytasksInput;
}

export interface OptionUpdateManyMutationInput {
  optionText?: Maybe<String>;
}

export interface MytaskUpsertWithWhereUniqueWithoutUserInput {
  where: MytaskWhereUniqueInput;
  update: MytaskUpdateWithoutUserDataInput;
  create: MytaskCreateWithoutUserInput;
}

export interface TaskUpsertWithoutQuestionsInput {
  update: TaskUpdateWithoutQuestionsDataInput;
  create: TaskCreateWithoutQuestionsInput;
}

export interface QuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  questionText?: Maybe<String>;
  questionText_not?: Maybe<String>;
  questionText_in?: Maybe<String[] | String>;
  questionText_not_in?: Maybe<String[] | String>;
  questionText_lt?: Maybe<String>;
  questionText_lte?: Maybe<String>;
  questionText_gt?: Maybe<String>;
  questionText_gte?: Maybe<String>;
  questionText_contains?: Maybe<String>;
  questionText_not_contains?: Maybe<String>;
  questionText_starts_with?: Maybe<String>;
  questionText_not_starts_with?: Maybe<String>;
  questionText_ends_with?: Maybe<String>;
  questionText_not_ends_with?: Maybe<String>;
  options_every?: Maybe<OptionWhereInput>;
  options_some?: Maybe<OptionWhereInput>;
  options_none?: Maybe<OptionWhereInput>;
  task?: Maybe<TaskWhereInput>;
  AND?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  OR?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  NOT?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
}

export interface MyrewardCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMyrewardsInput;
  reward: RewardCreateOneWithoutMyrewardsInput;
}

export interface MytaskUpdateWithoutTaskDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMytasksInput>;
  metadata?: Maybe<String>;
}

export interface UserCreateWithoutMyrewardsInput {
  id?: Maybe<ID_Input>;
  username: String;
  email: String;
  mytasks?: Maybe<MytaskCreateManyWithoutUserInput>;
  score?: Maybe<Int>;
}

export interface MytaskUpdateWithWhereUniqueWithoutTaskInput {
  where: MytaskWhereUniqueInput;
  data: MytaskUpdateWithoutTaskDataInput;
}

export interface MytaskCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  task: TaskCreateOneWithoutMytasksInput;
  metadata: String;
}

export interface UserUpsertWithoutMyrewardsInput {
  update: UserUpdateWithoutMyrewardsDataInput;
  create: UserCreateWithoutMyrewardsInput;
}

export interface TaskCreateWithoutMytasksInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type: String;
  taskScore: Int;
  questions?: Maybe<QuestionCreateManyWithoutTaskInput>;
}

export interface RewardUpdateOneRequiredWithoutMyrewardsInput {
  create?: Maybe<RewardCreateWithoutMyrewardsInput>;
  update?: Maybe<RewardUpdateWithoutMyrewardsDataInput>;
  upsert?: Maybe<RewardUpsertWithoutMyrewardsInput>;
  connect?: Maybe<RewardWhereUniqueInput>;
}

export interface QuestionCreateWithoutTaskInput {
  id?: Maybe<ID_Input>;
  questionText: String;
  options?: Maybe<OptionCreateManyWithoutQuestionInput>;
}

export interface RewardUpdateWithoutMyrewardsDataInput {
  decription?: Maybe<String>;
  url?: Maybe<String>;
  equivalentScore?: Maybe<Int>;
}

export interface OptionCreateWithoutQuestionInput {
  id?: Maybe<ID_Input>;
  optionText: String;
}

export interface RewardUpsertWithoutMyrewardsInput {
  update: RewardUpdateWithoutMyrewardsDataInput;
  create: RewardCreateWithoutMyrewardsInput;
}

export interface RewardCreateWithoutMyrewardsInput {
  id?: Maybe<ID_Input>;
  decription?: Maybe<String>;
  url: String;
  equivalentScore: Int;
}

export interface MytaskUpdateManyWithoutTaskInput {
  create?: Maybe<MytaskCreateWithoutTaskInput[] | MytaskCreateWithoutTaskInput>;
  delete?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  connect?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  set?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  disconnect?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
  update?: Maybe<
    | MytaskUpdateWithWhereUniqueWithoutTaskInput[]
    | MytaskUpdateWithWhereUniqueWithoutTaskInput
  >;
  upsert?: Maybe<
    | MytaskUpsertWithWhereUniqueWithoutTaskInput[]
    | MytaskUpsertWithWhereUniqueWithoutTaskInput
  >;
  deleteMany?: Maybe<MytaskScalarWhereInput[] | MytaskScalarWhereInput>;
  updateMany?: Maybe<
    | MytaskUpdateManyWithWhereNestedInput[]
    | MytaskUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneRequiredWithoutMyrewardsInput {
  create?: Maybe<UserCreateWithoutMyrewardsInput>;
  update?: Maybe<UserUpdateWithoutMyrewardsDataInput>;
  upsert?: Maybe<UserUpsertWithoutMyrewardsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TaskUpdateWithoutQuestionsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<String>;
  taskScore?: Maybe<Int>;
  mytasks?: Maybe<MytaskUpdateManyWithoutTaskInput>;
}

export interface RewardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  decription?: Maybe<String>;
  decription_not?: Maybe<String>;
  decription_in?: Maybe<String[] | String>;
  decription_not_in?: Maybe<String[] | String>;
  decription_lt?: Maybe<String>;
  decription_lte?: Maybe<String>;
  decription_gt?: Maybe<String>;
  decription_gte?: Maybe<String>;
  decription_contains?: Maybe<String>;
  decription_not_contains?: Maybe<String>;
  decription_starts_with?: Maybe<String>;
  decription_not_starts_with?: Maybe<String>;
  decription_ends_with?: Maybe<String>;
  decription_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  myrewards_every?: Maybe<MyrewardWhereInput>;
  myrewards_some?: Maybe<MyrewardWhereInput>;
  myrewards_none?: Maybe<MyrewardWhereInput>;
  equivalentScore?: Maybe<Int>;
  equivalentScore_not?: Maybe<Int>;
  equivalentScore_in?: Maybe<Int[] | Int>;
  equivalentScore_not_in?: Maybe<Int[] | Int>;
  equivalentScore_lt?: Maybe<Int>;
  equivalentScore_lte?: Maybe<Int>;
  equivalentScore_gt?: Maybe<Int>;
  equivalentScore_gte?: Maybe<Int>;
  AND?: Maybe<RewardWhereInput[] | RewardWhereInput>;
  OR?: Maybe<RewardWhereInput[] | RewardWhereInput>;
  NOT?: Maybe<RewardWhereInput[] | RewardWhereInput>;
}

export interface MytaskCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMytasksInput;
  task: TaskCreateOneWithoutMytasksInput;
  metadata: String;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  mytasks_every?: Maybe<MytaskWhereInput>;
  mytasks_some?: Maybe<MytaskWhereInput>;
  mytasks_none?: Maybe<MytaskWhereInput>;
  myrewards_every?: Maybe<MyrewardWhereInput>;
  myrewards_some?: Maybe<MyrewardWhereInput>;
  myrewards_none?: Maybe<MyrewardWhereInput>;
  score?: Maybe<Int>;
  score_not?: Maybe<Int>;
  score_in?: Maybe<Int[] | Int>;
  score_not_in?: Maybe<Int[] | Int>;
  score_lt?: Maybe<Int>;
  score_lte?: Maybe<Int>;
  score_gt?: Maybe<Int>;
  score_gte?: Maybe<Int>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserCreateOneWithoutMytasksInput {
  create?: Maybe<UserCreateWithoutMytasksInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MytaskSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MytaskWhereInput>;
  AND?: Maybe<MytaskSubscriptionWhereInput[] | MytaskSubscriptionWhereInput>;
  OR?: Maybe<MytaskSubscriptionWhereInput[] | MytaskSubscriptionWhereInput>;
  NOT?: Maybe<MytaskSubscriptionWhereInput[] | MytaskSubscriptionWhereInput>;
}

export interface UserCreateWithoutMytasksInput {
  id?: Maybe<ID_Input>;
  username: String;
  email: String;
  myrewards?: Maybe<MyrewardCreateManyWithoutUserInput>;
  score?: Maybe<Int>;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  mytasks?: Maybe<MytaskUpdateManyWithoutUserInput>;
  myrewards?: Maybe<MyrewardUpdateManyWithoutUserInput>;
  score?: Maybe<Int>;
}

export interface MyrewardCreateManyWithoutUserInput {
  create?: Maybe<
    MyrewardCreateWithoutUserInput[] | MyrewardCreateWithoutUserInput
  >;
  connect?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
}

export interface TaskUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<String>;
  taskScore?: Maybe<Int>;
  questions?: Maybe<QuestionUpdateManyWithoutTaskInput>;
  mytasks?: Maybe<MytaskUpdateManyWithoutTaskInput>;
}

export interface MyrewardCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  reward: RewardCreateOneWithoutMyrewardsInput;
}

export interface MyrewardUpsertWithWhereUniqueWithoutRewardInput {
  where: MyrewardWhereUniqueInput;
  update: MyrewardUpdateWithoutRewardDataInput;
  create: MyrewardCreateWithoutRewardInput;
}

export interface MytaskUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMytasksInput>;
  task?: Maybe<TaskUpdateOneRequiredWithoutMytasksInput>;
  metadata?: Maybe<String>;
}

export interface MytaskWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  task?: Maybe<TaskWhereInput>;
  metadata?: Maybe<String>;
  metadata_not?: Maybe<String>;
  metadata_in?: Maybe<String[] | String>;
  metadata_not_in?: Maybe<String[] | String>;
  metadata_lt?: Maybe<String>;
  metadata_lte?: Maybe<String>;
  metadata_gt?: Maybe<String>;
  metadata_gte?: Maybe<String>;
  metadata_contains?: Maybe<String>;
  metadata_not_contains?: Maybe<String>;
  metadata_starts_with?: Maybe<String>;
  metadata_not_starts_with?: Maybe<String>;
  metadata_ends_with?: Maybe<String>;
  metadata_not_ends_with?: Maybe<String>;
  AND?: Maybe<MytaskWhereInput[] | MytaskWhereInput>;
  OR?: Maybe<MytaskWhereInput[] | MytaskWhereInput>;
  NOT?: Maybe<MytaskWhereInput[] | MytaskWhereInput>;
}

export interface UserUpdateOneRequiredWithoutMytasksInput {
  create?: Maybe<UserCreateWithoutMytasksInput>;
  update?: Maybe<UserUpdateWithoutMytasksDataInput>;
  upsert?: Maybe<UserUpsertWithoutMytasksInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type TaskWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface UserUpdateWithoutMytasksDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  myrewards?: Maybe<MyrewardUpdateManyWithoutUserInput>;
  score?: Maybe<Int>;
}

export interface QuestionUpdateInput {
  questionText?: Maybe<String>;
  options?: Maybe<OptionUpdateManyWithoutQuestionInput>;
  task?: Maybe<TaskUpdateOneWithoutQuestionsInput>;
}

export interface MyrewardUpdateManyWithoutUserInput {
  create?: Maybe<
    MyrewardCreateWithoutUserInput[] | MyrewardCreateWithoutUserInput
  >;
  delete?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  connect?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  set?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  disconnect?: Maybe<MyrewardWhereUniqueInput[] | MyrewardWhereUniqueInput>;
  update?: Maybe<
    | MyrewardUpdateWithWhereUniqueWithoutUserInput[]
    | MyrewardUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | MyrewardUpsertWithWhereUniqueWithoutUserInput[]
    | MyrewardUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<MyrewardScalarWhereInput[] | MyrewardScalarWhereInput>;
}

export interface QuestionUpsertWithoutOptionsInput {
  update: QuestionUpdateWithoutOptionsDataInput;
  create: QuestionCreateWithoutOptionsInput;
}

export interface MyrewardUpdateWithWhereUniqueWithoutUserInput {
  where: MyrewardWhereUniqueInput;
  data: MyrewardUpdateWithoutUserDataInput;
}

export interface UserCreateOneWithoutMyrewardsInput {
  create?: Maybe<UserCreateWithoutMyrewardsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MyrewardUpdateWithoutUserDataInput {
  reward?: Maybe<RewardUpdateOneRequiredWithoutMyrewardsInput>;
}

export interface TaskCreateOneWithoutMytasksInput {
  create?: Maybe<TaskCreateWithoutMytasksInput>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface MyrewardUpsertWithWhereUniqueWithoutUserInput {
  where: MyrewardWhereUniqueInput;
  update: MyrewardUpdateWithoutUserDataInput;
  create: MyrewardCreateWithoutUserInput;
}

export interface OptionCreateManyWithoutQuestionInput {
  create?: Maybe<
    OptionCreateWithoutQuestionInput[] | OptionCreateWithoutQuestionInput
  >;
  connect?: Maybe<OptionWhereUniqueInput[] | OptionWhereUniqueInput>;
}

export interface MyrewardScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<MyrewardScalarWhereInput[] | MyrewardScalarWhereInput>;
  OR?: Maybe<MyrewardScalarWhereInput[] | MyrewardScalarWhereInput>;
  NOT?: Maybe<MyrewardScalarWhereInput[] | MyrewardScalarWhereInput>;
}

export interface MyrewardUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMyrewardsInput>;
  reward?: Maybe<RewardUpdateOneRequiredWithoutMyrewardsInput>;
}

export interface UserUpsertWithoutMytasksInput {
  update: UserUpdateWithoutMytasksDataInput;
  create: UserCreateWithoutMytasksInput;
}

export interface MyrewardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  reward?: Maybe<RewardWhereInput>;
  AND?: Maybe<MyrewardWhereInput[] | MyrewardWhereInput>;
  OR?: Maybe<MyrewardWhereInput[] | MyrewardWhereInput>;
  NOT?: Maybe<MyrewardWhereInput[] | MyrewardWhereInput>;
}

export interface MytaskUpdateManyMutationInput {
  metadata?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  score?: Maybe<Int>;
}

export interface OptionCreateInput {
  id?: Maybe<ID_Input>;
  optionText: String;
  question?: Maybe<QuestionCreateOneWithoutOptionsInput>;
}

export interface RewardUpdateManyMutationInput {
  decription?: Maybe<String>;
  url?: Maybe<String>;
  equivalentScore?: Maybe<Int>;
}

export interface QuestionCreateOneWithoutOptionsInput {
  create?: Maybe<QuestionCreateWithoutOptionsInput>;
  connect?: Maybe<QuestionWhereUniqueInput>;
}

export interface RewardUpdateInput {
  decription?: Maybe<String>;
  url?: Maybe<String>;
  myrewards?: Maybe<MyrewardUpdateManyWithoutRewardInput>;
  equivalentScore?: Maybe<Int>;
}

export interface QuestionCreateWithoutOptionsInput {
  id?: Maybe<ID_Input>;
  questionText: String;
  task?: Maybe<TaskCreateOneWithoutQuestionsInput>;
}

export interface QuestionCreateInput {
  id?: Maybe<ID_Input>;
  questionText: String;
  options?: Maybe<OptionCreateManyWithoutQuestionInput>;
  task?: Maybe<TaskCreateOneWithoutQuestionsInput>;
}

export interface TaskCreateOneWithoutQuestionsInput {
  create?: Maybe<TaskCreateWithoutQuestionsInput>;
  connect?: Maybe<TaskWhereUniqueInput>;
}

export interface MytaskCreateManyWithoutUserInput {
  create?: Maybe<MytaskCreateWithoutUserInput[] | MytaskCreateWithoutUserInput>;
  connect?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
}

export interface TaskCreateWithoutQuestionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type: String;
  taskScore: Int;
  mytasks?: Maybe<MytaskCreateManyWithoutTaskInput>;
}

export interface RewardCreateOneWithoutMyrewardsInput {
  create?: Maybe<RewardCreateWithoutMyrewardsInput>;
  connect?: Maybe<RewardWhereUniqueInput>;
}

export interface MytaskCreateManyWithoutTaskInput {
  create?: Maybe<MytaskCreateWithoutTaskInput[] | MytaskCreateWithoutTaskInput>;
  connect?: Maybe<MytaskWhereUniqueInput[] | MytaskWhereUniqueInput>;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionWhereInput>;
  AND?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
  OR?: Maybe<QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput>;
  NOT?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
}

export interface MyrewardUpdateWithWhereUniqueWithoutRewardInput {
  where: MyrewardWhereUniqueInput;
  data: MyrewardUpdateWithoutRewardDataInput;
}

export interface QuestionUpdateWithoutOptionsDataInput {
  questionText?: Maybe<String>;
  task?: Maybe<TaskUpdateOneWithoutQuestionsInput>;
}

export interface QuestionUpdateOneWithoutOptionsInput {
  create?: Maybe<QuestionCreateWithoutOptionsInput>;
  update?: Maybe<QuestionUpdateWithoutOptionsDataInput>;
  upsert?: Maybe<QuestionUpsertWithoutOptionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<QuestionWhereUniqueInput>;
}

export interface OptionUpdateInput {
  optionText?: Maybe<String>;
  question?: Maybe<QuestionUpdateOneWithoutOptionsInput>;
}

export interface MytaskCreateWithoutTaskInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMytasksInput;
  metadata: String;
}

export interface RewardCreateInput {
  id?: Maybe<ID_Input>;
  decription?: Maybe<String>;
  url: String;
  myrewards?: Maybe<MyrewardCreateManyWithoutRewardInput>;
  equivalentScore: Int;
}

export interface TaskUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<String>;
  taskScore?: Maybe<Int>;
}

export interface UserUpdateWithoutMyrewardsDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  mytasks?: Maybe<MytaskUpdateManyWithoutUserInput>;
  score?: Maybe<Int>;
}

export interface QuestionCreateManyWithoutTaskInput {
  create?: Maybe<
    QuestionCreateWithoutTaskInput[] | QuestionCreateWithoutTaskInput
  >;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  email: String;
  score?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  score: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  score: () => Promise<AsyncIterator<Int>>;
}

export interface MytaskConnection {
  pageInfo: PageInfo;
  edges: MytaskEdge[];
}

export interface MytaskConnectionPromise
  extends Promise<MytaskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MytaskEdge>>() => T;
  aggregate: <T = AggregateMytaskPromise>() => T;
}

export interface MytaskConnectionSubscription
  extends Promise<AsyncIterator<MytaskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MytaskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMytaskSubscription>() => T;
}

export interface Mytask {
  id: ID_Output;
  metadata: String;
}

export interface MytaskPromise extends Promise<Mytask>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  task: <T = TaskPromise>() => T;
  metadata: () => Promise<String>;
}

export interface MytaskSubscription
  extends Promise<AsyncIterator<Mytask>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  task: <T = TaskSubscription>() => T;
  metadata: () => Promise<AsyncIterator<String>>;
}

export interface MytaskNullablePromise
  extends Promise<Mytask | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  task: <T = TaskPromise>() => T;
  metadata: () => Promise<String>;
}

export interface AggregateMyreward {
  count: Int;
}

export interface AggregateMyrewardPromise
  extends Promise<AggregateMyreward>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMyrewardSubscription
  extends Promise<AsyncIterator<AggregateMyreward>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Task {
  id: ID_Output;
  name: String;
  description?: String;
  type: String;
  taskScore: Int;
}

export interface TaskPromise extends Promise<Task>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<String>;
  taskScore: () => Promise<Int>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  mytasks: <T = FragmentableArray<Mytask>>(args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TaskSubscription
  extends Promise<AsyncIterator<Task>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  taskScore: () => Promise<AsyncIterator<Int>>;
  questions: <T = Promise<AsyncIterator<QuestionSubscription>>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  mytasks: <T = Promise<AsyncIterator<MytaskSubscription>>>(args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TaskNullablePromise
  extends Promise<Task | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<String>;
  taskScore: () => Promise<Int>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  mytasks: <T = FragmentableArray<Mytask>>(args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface TaskSubscriptionPayload {
  mutation: MutationType;
  node: Task;
  updatedFields: String[];
  previousValues: TaskPreviousValues;
}

export interface TaskSubscriptionPayloadPromise
  extends Promise<TaskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TaskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TaskPreviousValuesPromise>() => T;
}

export interface TaskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TaskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TaskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TaskPreviousValuesSubscription>() => T;
}

export interface Question {
  id: ID_Output;
  questionText: String;
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  questionText: () => Promise<String>;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  task: <T = TaskPromise>() => T;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  questionText: () => Promise<AsyncIterator<String>>;
  options: <T = Promise<AsyncIterator<OptionSubscription>>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  task: <T = TaskSubscription>() => T;
}

export interface QuestionNullablePromise
  extends Promise<Question | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  questionText: () => Promise<String>;
  options: <T = FragmentableArray<Option>>(args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  task: <T = TaskPromise>() => T;
}

export interface MyrewardEdge {
  node: Myreward;
  cursor: String;
}

export interface MyrewardEdgePromise
  extends Promise<MyrewardEdge>,
    Fragmentable {
  node: <T = MyrewardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MyrewardEdgeSubscription
  extends Promise<AsyncIterator<MyrewardEdge>>,
    Fragmentable {
  node: <T = MyrewardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Myreward {
  id: ID_Output;
}

export interface MyrewardPromise extends Promise<Myreward>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  reward: <T = RewardPromise>() => T;
}

export interface MyrewardSubscription
  extends Promise<AsyncIterator<Myreward>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  reward: <T = RewardSubscription>() => T;
}

export interface MyrewardNullablePromise
  extends Promise<Myreward | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  reward: <T = RewardPromise>() => T;
}

export interface AggregateTask {
  count: Int;
}

export interface AggregateTaskPromise
  extends Promise<AggregateTask>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTaskSubscription
  extends Promise<AsyncIterator<AggregateTask>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MyrewardSubscriptionPayload {
  mutation: MutationType;
  node: Myreward;
  updatedFields: String[];
  previousValues: MyrewardPreviousValues;
}

export interface MyrewardSubscriptionPayloadPromise
  extends Promise<MyrewardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MyrewardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MyrewardPreviousValuesPromise>() => T;
}

export interface MyrewardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MyrewardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MyrewardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MyrewardPreviousValuesSubscription>() => T;
}

export interface TaskConnection {
  pageInfo: PageInfo;
  edges: TaskEdge[];
}

export interface TaskConnectionPromise
  extends Promise<TaskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TaskEdge>>() => T;
  aggregate: <T = AggregateTaskPromise>() => T;
}

export interface TaskConnectionSubscription
  extends Promise<AsyncIterator<TaskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TaskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTaskSubscription>() => T;
}

export interface MyrewardPreviousValues {
  id: ID_Output;
}

export interface MyrewardPreviousValuesPromise
  extends Promise<MyrewardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MyrewardPreviousValuesSubscription
  extends Promise<AsyncIterator<MyrewardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateReward {
  count: Int;
}

export interface AggregateRewardPromise
  extends Promise<AggregateReward>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRewardSubscription
  extends Promise<AsyncIterator<AggregateReward>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TaskPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  type: String;
  taskScore: Int;
}

export interface TaskPreviousValuesPromise
  extends Promise<TaskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<String>;
  taskScore: () => Promise<Int>;
}

export interface TaskPreviousValuesSubscription
  extends Promise<AsyncIterator<TaskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  taskScore: () => Promise<AsyncIterator<Int>>;
}

export interface RewardConnection {
  pageInfo: PageInfo;
  edges: RewardEdge[];
}

export interface RewardConnectionPromise
  extends Promise<RewardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RewardEdge>>() => T;
  aggregate: <T = AggregateRewardPromise>() => T;
}

export interface RewardConnectionSubscription
  extends Promise<AsyncIterator<RewardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RewardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRewardSubscription>() => T;
}

export interface MytaskSubscriptionPayload {
  mutation: MutationType;
  node: Mytask;
  updatedFields: String[];
  previousValues: MytaskPreviousValues;
}

export interface MytaskSubscriptionPayloadPromise
  extends Promise<MytaskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MytaskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MytaskPreviousValuesPromise>() => T;
}

export interface MytaskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MytaskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MytaskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MytaskPreviousValuesSubscription>() => T;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MytaskPreviousValues {
  id: ID_Output;
  metadata: String;
}

export interface MytaskPreviousValuesPromise
  extends Promise<MytaskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  metadata: () => Promise<String>;
}

export interface MytaskPreviousValuesSubscription
  extends Promise<AsyncIterator<MytaskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  metadata: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface MytaskEdge {
  node: Mytask;
  cursor: String;
}

export interface MytaskEdgePromise extends Promise<MytaskEdge>, Fragmentable {
  node: <T = MytaskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MytaskEdgeSubscription
  extends Promise<AsyncIterator<MytaskEdge>>,
    Fragmentable {
  node: <T = MytaskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionPreviousValues {
  id: ID_Output;
  optionText: String;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  optionText: () => Promise<String>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionText: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  username: String;
  email: String;
  score?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  mytasks: <T = FragmentableArray<Mytask>>(args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  myrewards: <T = FragmentableArray<Myreward>>(args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  score: () => Promise<Int>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mytasks: <T = Promise<AsyncIterator<MytaskSubscription>>>(args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  myrewards: <T = Promise<AsyncIterator<MyrewardSubscription>>>(args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  score: () => Promise<AsyncIterator<Int>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  mytasks: <T = FragmentableArray<Mytask>>(args?: {
    where?: MytaskWhereInput;
    orderBy?: MytaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  myrewards: <T = FragmentableArray<Myreward>>(args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  score: () => Promise<Int>;
}

export interface MyrewardConnection {
  pageInfo: PageInfo;
  edges: MyrewardEdge[];
}

export interface MyrewardConnectionPromise
  extends Promise<MyrewardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MyrewardEdge>>() => T;
  aggregate: <T = AggregateMyrewardPromise>() => T;
}

export interface MyrewardConnectionSubscription
  extends Promise<AsyncIterator<MyrewardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MyrewardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMyrewardSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  questionText: String;
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  questionText: () => Promise<String>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  questionText: () => Promise<AsyncIterator<String>>;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Option {
  id: ID_Output;
  optionText: String;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  optionText: () => Promise<String>;
  question: <T = QuestionPromise>() => T;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionText: () => Promise<AsyncIterator<String>>;
  question: <T = QuestionSubscription>() => T;
}

export interface OptionNullablePromise
  extends Promise<Option | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  optionText: () => Promise<String>;
  question: <T = QuestionPromise>() => T;
}

export interface RewardPreviousValues {
  id: ID_Output;
  decription?: String;
  url: String;
  equivalentScore: Int;
}

export interface RewardPreviousValuesPromise
  extends Promise<RewardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  decription: () => Promise<String>;
  url: () => Promise<String>;
  equivalentScore: () => Promise<Int>;
}

export interface RewardPreviousValuesSubscription
  extends Promise<AsyncIterator<RewardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  decription: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  equivalentScore: () => Promise<AsyncIterator<Int>>;
}

export interface RewardSubscriptionPayload {
  mutation: MutationType;
  node: Reward;
  updatedFields: String[];
  previousValues: RewardPreviousValues;
}

export interface RewardSubscriptionPayloadPromise
  extends Promise<RewardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RewardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RewardPreviousValuesPromise>() => T;
}

export interface RewardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RewardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RewardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RewardPreviousValuesSubscription>() => T;
}

export interface Reward {
  id: ID_Output;
  decription?: String;
  url: String;
  equivalentScore: Int;
}

export interface RewardPromise extends Promise<Reward>, Fragmentable {
  id: () => Promise<ID_Output>;
  decription: () => Promise<String>;
  url: () => Promise<String>;
  myrewards: <T = FragmentableArray<Myreward>>(args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  equivalentScore: () => Promise<Int>;
}

export interface RewardSubscription
  extends Promise<AsyncIterator<Reward>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  decription: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  myrewards: <T = Promise<AsyncIterator<MyrewardSubscription>>>(args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  equivalentScore: () => Promise<AsyncIterator<Int>>;
}

export interface RewardNullablePromise
  extends Promise<Reward | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  decription: () => Promise<String>;
  url: () => Promise<String>;
  myrewards: <T = FragmentableArray<Myreward>>(args?: {
    where?: MyrewardWhereInput;
    orderBy?: MyrewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  equivalentScore: () => Promise<Int>;
}

export interface TaskEdge {
  node: Task;
  cursor: String;
}

export interface TaskEdgePromise extends Promise<TaskEdge>, Fragmentable {
  node: <T = TaskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TaskEdgeSubscription
  extends Promise<AsyncIterator<TaskEdge>>,
    Fragmentable {
  node: <T = TaskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMytask {
  count: Int;
}

export interface AggregateMytaskPromise
  extends Promise<AggregateMytask>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMytaskSubscription
  extends Promise<AsyncIterator<AggregateMytask>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface RewardEdge {
  node: Reward;
  cursor: String;
}

export interface RewardEdgePromise extends Promise<RewardEdge>, Fragmentable {
  node: <T = RewardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RewardEdgeSubscription
  extends Promise<AsyncIterator<RewardEdge>>,
    Fragmentable {
  node: <T = RewardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Task",
    embedded: false
  },
  {
    name: "Mytask",
    embedded: false
  },
  {
    name: "Question",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  },
  {
    name: "Reward",
    embedded: false
  },
  {
    name: "Myreward",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
